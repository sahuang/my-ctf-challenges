from functools import reduce
import gmpy2, ecdsa
from hashlib import sha256
from Crypto.Util.number import long_to_bytes, bytes_to_long
from pwn import *
from pwnlib.util.iters import bruteforce
from parse import *
import string
from base64 import b64decode

def CRT(items):
    N = reduce(lambda x, y: x * y, (i[1] for i in items))
    res = 0
    for a, n in items:
        m = N // n
        d, r, s = gmpy2.gcdext(n, m)
        if d != 1:
            raise
        res += a * m * s
    return res % N, N

def brute_force(prefix,s):
	return bruteforce(lambda x:sha256(x.encode()+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method='fixed')

conn = remote('104.197.118.147', 10140)
conn.recvuntil(b'robot...\n\n')
proof = conn.recvline().decode().strip()
prefix, s = parse("sha256(???? + {}) == {}", proof)
pow_res = brute_force(prefix.encode(), s)
conn.sendlineafter(b"Your answer: ", pow_res.encode())

conn.recvuntil(b"Signature: ")
s1 = eval(conn.recvline().strip().decode())
conn.recvuntil(b"Signature: ")
s2 = eval(conn.recvline().strip().decode())

n = []
c = []
e = 3
for _ in range(3):
    conn.recvuntil(b"N = ")
    n.append(int(conn.recvline().strip().decode()))
    conn.recvuntil(b"Ciphertext = ")
    c.append(bytes_to_long(b64decode(conn.recvline().strip())))
print(n)
print(c)

x, n = CRT(list(zip(c, n)))
m = long_to_bytes(gmpy2.iroot(gmpy2.mpz(x), e)[0])

STUDENT_NAME = 'jayden_vs'
report_signed = STUDENT_NAME.encode('utf-8') + m
order = ecdsa.curves.NIST384p.generator.order()
hm1 = int(sha256(report_signed[:len(report_signed) // 2]).hexdigest(), 16)
hm2 = int(sha256(report_signed[len(report_signed) // 2:]).hexdigest(), 16)
k = (hm1 - hm2) * gmpy2.invert(s1[1] - s2[1], order) % order
d = (k * s1[1] - hm1) * gmpy2.invert(s1[0], order) % order
print(d)

conn.sendlineafter(b"My secret key when communicating with professor: ", str(d).encode())
conn.interactive()