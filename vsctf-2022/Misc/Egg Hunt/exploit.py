from pwn import *
from math import *
from tqdm import tqdm
from sympy.ntheory.modular import crt

conn = remote('104.197.118.147', 10100)

# LEVEL 1
# Strategy: Simply dig 41 different cells and then submit.
# There is 41/100 chance you will succeed so try a few times and you can easily pass level 1.
print("LEVEL 1 Starting...")
for i in tqdm(range(41)):
    conn.recvuntil(b"Your choice: ")
    conn.sendline(b"d")
    conn.recvuntil(b"space): ")
    conn.sendline(f"{i // 10} {i % 10}".encode())
conn.recvuntil(b"Your choice: ")
conn.sendline(b"s")
print(conn.recvline().decode())

# LEVEL 2
# Strategy: Do a simple binary search on 1-1000. Since 2^10 > 1000 we are guaranteed to find the egg within 10 tries.
print("LEVEL 2 Starting...")
for _ in tqdm(range(20)):
	l = 1
	r = 1000
	while True:
		mid = (l + r) // 2
		conn.recvuntil(b"Your choice: ")
		conn.sendline(b"p")
		conn.recvuntil(b"(1-1000): ")
		conn.sendline(str(mid).encode())
		res = conn.recvline().decode().strip()
		if "big" in res:
			r = mid
		elif "small" in res:
			l = mid + 1
		else:
			break
print(conn.recvline().decode())

# LEVEL 3
# Strategy: Choose a list of numbers: [23,19,17,13,11,9,7,5,4]. Their LCM = 1338557220. 
# We query 23 rounds with u = LCM, v = 1,2,...,23. If gcd(LCM, secret+v) = k (in the list), 
# then we know secret = -v (mod k). CRT can finally be used to obtain the number.
# This is a reference to https://codeforces.com/blog/entry/101663 D: GCD Guess.
print("LEVEL 3 Starting...")
nums = [23,19,17,13,11,9,7,5,4]
LCM = 1338557220
for _ in tqdm(range(20)):
	rems = [None] * 9
	for i in range(1, 24):
		conn.recvuntil(b"Your choice: ")
		conn.sendline(b"p")
		conn.recvuntil(b"space: ")
		conn.sendline(f"{LCM} {i}".encode())
		res = conn.recvline().decode().strip()
		# example: gcd(1338557220, secret + 1) = 11. 20/25
		res = int(res[res.index("=")+2 : res.index(".")])
		for j in range(9):
			if res % nums[j] == 0:
				rems[j] = -i
	for _ in range(2):
		conn.recvuntil(b"Your choice: ")
		conn.sendline(b"p")
		conn.recvuntil(b"space: ")
		conn.sendline(b"1 1")
		conn.recvline()
	conn.recvuntil(b"What is the secret: ")
	answer = crt(nums, rems)[0]
	conn.sendline(str(answer).encode())
print(conn.recvline().decode())

# LEVEL 4
# Reference: https://codeforces.com/problemset/problem/1666/I
# It is actually printing the sum of Manhattan distances from the cell picked to the 2 egg cells.
# Strategy: Suppose eggs in (x1, y1), (x2, y2). Assume x2 >= x1 and y2 >= y1. m=20.
# Op1: Pick (0, 0)   -> A = x1 + x2 + y1 + y2
# Op2: Pick (0, m-1) -> B = x1 + x2 + (m-1-y1) + (m-1-y2)
# Sx = x1+x2 = (A+B+2-2m)/2, Sy = y1+y2 = (A-B+2m-2)/2
# Op3: Pick (floor(Sx/2), 0) -> C = (x2 - x1) + y1 + y2
# Op4: Pick (0, floor(Sy/2)) -> D = x1 + x2 + (y2 - y1)
# Dx = x2-x1 = C-Sy, Dy = y2-y1 = D-Sx
# x1 = (Sx-Dx)/2, x2 = (Sx+Dx)/2, y1 = (Sy-Dy)/2, y2 = (Sy+Dy)/2
# Op5: Dig (x1, y1) -> If we find the egg then Op6 (x2, y2)
# If we didn't find the egg, Op6 and Op7 will be (x1, y2) and (x2, y1).
# This is because both pairs of points give the same Manhattan distances for all possible pick.
print("LEVEL 4 Starting...")
m = 20
for _ in tqdm(range(10)):
	# Op1: Pick (0, 0)
	conn.recvuntil(b"Your choice: ")
	conn.sendline(b"p")
	conn.recvuntil(b"space): ")
	conn.sendline(b"0 0")
	res = conn.recvline().decode().strip()
	A = int(res[res.index(":")+2:])
	# Op2: Pick (0, m-1)
	conn.recvuntil(b"Your choice: ")
	conn.sendline(b"p")
	conn.recvuntil(b"space): ")
	conn.sendline(f"0 {m-1}".encode())
	res = conn.recvline().decode().strip()
	B = int(res[res.index(":")+2:])
	Sx = (A+B+2-2*m)/2
	Sy = (A-B+2*m-2)/2
	# Op3: Pick (floor(Sx/2), 0)
	conn.recvuntil(b"Your choice: ")
	conn.sendline(b"p")
	conn.recvuntil(b"space): ")
	conn.sendline(f"{floor(Sx/2)} 0".encode())
	res = conn.recvline().decode().strip()
	C = int(res[res.index(":")+2:])
	# Op4: Pick (0, floor(Sy/2))
	conn.recvuntil(b"Your choice: ")
	conn.sendline(b"p")
	conn.recvuntil(b"space): ")
	conn.sendline(f"0 {floor(Sy/2)}".encode())
	res = conn.recvline().decode().strip()
	D = int(res[res.index(":")+2:])
	Dx = C-Sy
	Dy = D-Sx
	x1 = int((Sx-Dx)//2)
	x2 = int((Sx+Dx)//2)
	y1 = int((Sy-Dy)//2)
	y2 = int((Sy+Dy)//2)
	# Op5: Dig (x1, y1)
	conn.recvuntil(b"Your choice: ")
	conn.sendline(b"d")
	conn.recvuntil(b"space): ")
	conn.sendline(f"{x1} {y1}".encode())
	if "Try again!" in conn.recvline().decode().strip():
		# Op6 and Op7 will be (x1, y2) and (x2, y1)
		conn.recvuntil(b"Your choice: ")
		conn.sendline(b"d")
		conn.recvuntil(b"space): ")
		conn.sendline(f"{x1} {y2}".encode())
		conn.recvuntil(b"Your choice: ")
		conn.sendline(b"d")
		conn.recvuntil(b"space): ")
		conn.sendline(f"{x2} {y1}".encode())
	else:
		conn.recvuntil(b"Your choice: ")
		conn.sendline(b"d")
		conn.recvuntil(b"space): ")
		conn.sendline(f"{x2} {y2}".encode())

conn.interactive()

# vsctf{Congratulations!You_hunted_the_VS_eggs,please_enjoy_the_chocolate_flags---Yummy!}